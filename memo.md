generated by Gemini 2.5 Pro

### `oxide_control`: Crate Design & API Structure

#### 1\. Core Philosophy & Design Principles

  * **Safety & Type-Safety:** Pythonの動的型付けに起因する実行時エラー（次元の不一致など）を、Rustの型システムと所有権モデルを用いてコンパイル時に撲滅する。APIは不正な状態遷移を静的に防止する。
  * **Performance & Concurrency:** `rusty_mujoco`が提供するゼロコストに近いFFI性能を活かし、シミュレーションのオーバーヘッドを最小化する。GILの制約を受けない、真に並列な大規模環境シミュレーションを容易に実現する。
  * **Modularity & Composability:** 物理モデル、タスク、報酬、観測を独立したコンポーネントとして定義し、それらを宣言的に組み合わせることで、複雑な環境を安全かつ容易に構築できる`trait`ベースのアーキテクチャを採用する。
  * **Ergonomics & Discoverability:** `dm_control`ユーザーが親しみやすい高レベルAPIと、Rust開発者にとって慣用的で直感的なAPI（ビルダーパターン、`trait`など）の両方を提供する。

#### 2\. Crate Module Structure

クレートは、明確な関心分離に基づき、以下のように構成されます。

oxide\_control/
├── src/
│   ├── lib.rs          // Crate root, re-exports key components
│   ├── core.rs         // Core traits: Environment, TimeStep, Space
│   ├── physics.rs      // Physics: MuJoCoの安全な高レベルラッパー
│   ├── composer/       // Declarative environment construction
│   │   ├── mod.rs      // Composer builder and component traits
│   │   ├── task.rs     // Task trait and implementations
│   │   ├── reward.rs   // RewardFn trait and implementations (incl. Weighted)
│   │   └── observable.rs // Observable trait and implementations
│   ├── suite/          // Standard benchmark environments
│   │   ├── mod.rs      // suite::load() high-level API
│   │   └── domains/    // Implementations for cartpole, walker, etc.
│   ├── viewer.rs       // Interactive 3D viewer
│   └── wrappers/       // Common environment wrappers
│       ├── mod.rs
│       ├── time\_limit.rs
│       └── frame\_stack.rs
└── examples/
├── basic\_usage.rs
├── custom\_environment.rs
└── train\_agent.rs

#### 3\. Core Abstractions (The Trait System)

APIの中核は、環境とエージェント間のインタラクションを定義する`trait`群です。

  * **`Environment` Trait:** 強化学習環境が満たすべき契約を定義します。

    ```rust
    pub trait Environment {
        type Observation;
        type Action;

        fn reset(&mut self) -> TimeStep<Self::Observation>;
        fn step(&mut self, action: &Self::Action) -> TimeStep<Self::Observation>;
        fn action_spec(&self) -> &dyn Space<Sample = Self::Action>;
        fn observation_spec(&self) -> &dyn Space<Sample = Self::Observation>;
    }
    ```

  * **`TimeStep` Struct:** エージェントと環境間のリッチな情報伝達を担います。

    ```rust
    pub struct TimeStep<O> {
        pub step_type: StepType, // First, Mid, Last
        pub reward: f32,
        pub discount: f32,
        pub observation: O,
    }
    ```

  * **`Space` Trait:** 観測空間と行動空間の仕様（形状、データ型、範囲）を抽象化します。

    ```rust
    pub trait Space {
        type Sample;
        fn shape(&self) -> &[usize];
        //...
    }
    ```

#### 4\. The `Composer` API: 宣言的な環境構築

`Composer`は、独立したコンポーネントを組み合わせ、`Environment`を宣言的に構築するためのビルダーです。

  * **`Physics` Component:**

      * **役割:** `rusty_mujoco`を安全にカプセル化し、シミュレーションの「真の状態 (`state`)」を管理する。`Composer`の物理的な土台となる。
      * **API:** `Physics::from_xml_path(path)`で生成。`step()`, `reset()`, `control()` (制御入力用), `data()` (状態読み取り用) といった高レベルメソッドを提供。

  * **`Task` Component:**

      * **役割:** 「何をすべきか」という目標と、エピソードのライフサイクル（初期化、終了条件）を定義する。
      * **設計:** `.task()`はオプショナルなビルダーメソッド。これにより、タスクを持たない純粋な物理シミュレーション（サンドボックス）環境の構築も可能となり、APIの柔軟性が向上する。
      * **Trait:** `trait Task { fn initialize_episode(&self, physics: &mut Physics); fn should_terminate(&self, physics: &Physics) -> bool;... }`

  * **`Observable` Component:**

      * **役割:** エージェントが知覚できる「観測 (`observation`)」を生成する。`state`から`observation`への変換を担う。
      * **Trait:** `trait Observable { fn observe(&self, physics: &Physics) -> DVector<f32>;... }`
      * **構築:** `.add_observable()`で追加された順に連結され、最終的な観測ベクトルを形成する。

  * **`RewardFn` Component:**

      * **役割:** 「行動の良し悪し」を評価する報酬値を計算する。
      * **Trait:** `trait RewardFn { fn calculate_reward(&self, physics: &Physics) -> f32; }`
      * **構築:** `.add_reward_fn()`で追加された報酬関数の結果が合計され、最終的な報酬となる。

  * **`Composer` Builder API:**

    ```rust
    use oxide_control::composer::{Composer, reward::Weighted};
    use oxide_control::physics::Physics;
    //... import specific Task, RewardFn, Observable components

    // 1. 物理基盤を定義
    let physics = Physics::from_xml_path("path/to/robot.xml")?;

    // 2. Composerで宣言的に環境を構築
    let env = Composer::new(physics)
       .task(MyTask::new())
       .add_reward_fn(Weighted::new(1.0, ForwardVelocityReward)) // 重み付けラッパーを使用
       .add_reward_fn(Weighted::new(-0.1, ControlCostPenalty))
       .add_observable(JointPositions::all())
       .add_observable(BodyHeight::new("torso"))
       .build(); // `impl Environment` を返す

    // `env`は標準的なRLエージェントと対話可能
    ```

#### 5\. 高レベルAPIとエコシステム統合

  * **`suite`モジュール:**

      * `dm_control.suite`に相当。`suite::load("walker", "walk")`のように、標準ベンチマークを一行でロードできる高レベルAPIを提供。

  * **`viewer`モジュール:**

      * `viewer::launch(env)`で、任意の`Environment`をインタラクティブに可視化。デバッグと分析を容易にする。

  * **`wrappers`モジュール:**

      * `TimeLimit`, `ActionRepeat`, `FrameStack`など、既存の`Environment`の振る舞いを修飾する、再利用可能なラッパー群。

  * **エコシステム統合:**

      * **`nalgebra`:** 観測、行動、内部計算におけるベクトル・行列の表現には、デファクトスタンダードである`nalgebra`を一貫して使用。
      * **RL Agent Libraries:** `rl`、`border`、`relearn` といったRustのRLライブラリが、`oxide_control`の`Environment`を直接利用できるよう、協調してAPIを設計する。

#### 6\. 結論：戦略的価値

`oxide_control`は、単なるシミュレーション環境のコレクションではありません。これは、Rustの型安全性、パフォーマンス、そして構成可能性を最大限に活用し、ロボティクスと強化学習の研究開発における生産性、信頼性、再現性を飛躍的に向上させるための、**中核的なプラットフォーム**です。`rusty_mujoco`と組み合わせることで、シミュレーションから実世界へのシームレスな移行を視野に入れた、エンドツーエンドのRustネイティブな開発ワークフローを実現します。




### `oxide_control::composer::Task` Trait：定義と設計

#### 1\. 概念：タスクの責務とは何か？

`Composer`の設計思想において、`Task`コンポーネントは、強化学習環境における\*\*「目標」と「エピソードの進行管理」\*\*という、極めて重要な責務を担います。

物理法則を司る`Physics`、報酬を計算する`RewardFn`、観測を生成する`Observable`とは明確に分離されており、`Task`は以下の問いに答えるロジックをカプセル化します。

  * **どうやってエピソードを開始するか？ (Initialization):**
    エピソードが始まるたびに、ロボットや環境を特定の初期状態に設定する必要があります。例えば、ロボットを常に同じ立位姿勢から開始させる、あるいはターゲットの位置をランダムに再配置するなどです。

  * **いつエピソードを終了するか？ (Termination):**
    エピソードは無限に続くわけではありません。タスクの成功（例：目標地点への到達）、失敗（例：ロボットの転倒）、あるいは単なる時間切れ（タイムアウト）といった条件を判定し、エピソードを終了させる必要があります。

`Task`は、いわばRL環境における「ゲームのルールブック」です。物理法則とは独立した、その課題特有のルールを定義します。

#### 2\. `Task` TraitのAPI定義

この責務をRustの`trait`として表現すると、以下のようになります。

```rust
use crate::physics::Physics;

/// 環境におけるタスクの目標とエピソードのライフサイクルを定義するトレイト。
///
/// このトレイトを実装することで、エピソードの開始時に環境をどのように
/// 初期化するか、また、どのような条件でエピソードを終了するかを定義できる。
pub trait Task {
    /// エピソードの開始時に呼び出される。
    ///
    /// このメソッドは、物理環境を特定またはランダムな初期状態に設定する責務を持つ。
    /// 例えば、ロボットの関節を初期角度に設定したり、ターゲットの位置を
    /// ランダム化したりする。
    ///
    /// # Arguments
    /// * `physics` - 可変の参照。物理状態を直接変更できる。
    fn initialize_episode(&self, physics: &mut Physics) {
        // デフォルトでは何もしない。
        // 多くのタスクはMJCFファイルで定義されたデフォルト状態から開始すれば十分。
    }

    /// 各物理ステップの後に呼び出され、エピソードが終了すべきかどうかを判定する。
    ///
    /// trueを返すと、次の`TimeStep`の`step_type`が`StepType::Last`に設定される。
    ///
    /// # Arguments
    /// * `physics` - 読み取り専用の参照。現在の物理状態を元に終了条件を判定する。
    ///
    /// # Returns
    /// エピソードを終了すべきであれば`true`、そうでなければ`false`。
    fn should_terminate(&self, physics: &Physics) -> bool {
        // デフォルトでは決して終了しない。
        // 終了条件はラッパー（例: TimeLimit）で別途定義することも可能。
        false
    }

    // 必要に応じて、before_stepやafter_stepのようなフックを追加することも可能だが、
    // APIのシンプルさを保つため、まずは必須の機能に絞る。
}
```

#### 3\. 各メソッドの詳細解説

  * **`fn initialize_episode(&self, physics: &mut Physics)`**

      * **目的:** 新しいエピソードの開始時に、環境を準備します。
      * **引数:** `&mut Physics`を受け取ります。これは、このメソッドが物理世界の**状態を直接変更する**（例：ロボットの位置をリセットする）必要があるためです。
      * **デフォルト実装:** デフォルトでは空の実装を提供します。これは、多くの単純なタスクでは、MJCFファイルに定義されたデフォルトの初期状態で十分であり、特別な初期化ロジックが不要な場合があるためです。これにより、`Task`トレイトの実装が容易になります。

  * **`fn should_terminate(&self, physics: &Physics) -> bool`**

      * **目的:** 各物理ステップの後に、エピソードを終了すべきかを判定します。
      * **引数:** `&Physics`（読み取り専用の参照）を受け取ります。終了判定は現在の物理状態を**読み取る**だけでよく、変更する必要はないためです。例えば、「ロボットの胴体の高さが一定以下になったら（転倒したら）終了」といったロジックを実装します。
      * **デフォルト実装:** デフォルトでは`false`を返します。これにより、タスクが本質的に終了条件を持たない場合（例：純粋なサンドボックス環境）や、終了条件を`TimeLimit`のような別のラッパーで管理したい場合に、このメソッドを実装する必要がなくなります。

#### 4\. 設計上の重要な判断：なぜ報酬計算を分離したか

`Task`トレイトに`get_reward`のようなメソッドを含めることも考えられますが、`oxide_control`の設計では、これを意図的に**分離**し、独立した`RewardFn`トレイトに委ねています。

  * **理由:** これは「関心の分離」の原則に基づきます。
      * **タスクの目標**（例：「前に進む」）と、
      * **その目標達成度を評価する具体的な報酬関数**（例：「前進速度に比例した報酬を与える」「制御入力の大きさにペナルティを与える」）
        は、概念的に異なるものです。これらを分離することで、同じ「走る」というタスクに対して、異なる報酬設計を試すことが非常に容易になります。例えば、エネルギー効率を重視する報酬と、速度のみを重視する報酬を、`Task`コンポーネントを変更することなく、`RewardFn`コンポーネントを差し替えるだけで比較実験できます。

この設計により、`Task`はエピソードの構造的な流れ（開始と終了）という単一の責務に集中でき、システム全体のモジュール性と再利用性が大幅に向上します。





### `oxide_control::composer::Composer` の定義

```rust
use crate::physics::Physics;
use crate::composer::{
    task::Task,
    reward::RewardFn,
    observable::Observable,
};
use crate::core::Environment; // ComposedEnvironmentが実装するトレイト

/// 強化学習環境を宣言的に構築するためのビルダー。
///
/// この構造体は、物理シミュレーションの基盤(`Physics`)の上に、
/// タスクの目標(`Task`)、報酬関数(`RewardFn`)、観測要素(`Observable`)を
/// 積み重ねていくことで、最終的な`Environment`を生成する。
pub struct Composer {
    /// この環境の物理的な土台。世界の法則と状態を管理する。
    /// Composerは常に単一のPhysicsインスタンスを持つ。
    physics: Physics,

    /// 環境の「目標」とエピソードのライフサイクルを定義する。
    /// タスクはオプショナルであり、設定されない場合、環境は
    /// 終了条件を持たない純粋な物理シミュレーションとして機能する。
    task: Option<Box<dyn Task>>,

    /// 報酬を計算するためのコンポーネントのリスト。
    /// 最終的な報酬は、このリストに含まれる全ての報酬関数の結果の合計となる。
    reward_fns: Vec<Box<dyn RewardFn>>,

    /// エージェントへの観測ベクトルを構成するためのコンポーネントのリスト。
    /// 最終的な観測は、このリストの順序で各観測ベクトルの結果を連結したものとなる。
    observables: Vec<Box<dyn Observable>>,
}

// --- メソッド実装 ---

impl Composer {
    /// 新しいComposerインスタンスを生成する。
    ///
    /// # Arguments
    /// * `physics` - この環境の物理的な土台となる`Physics`インスタンス。
    ///             Composerはこのオブジェクトの所有権を得る。
    pub fn new(physics: Physics) -> Self {
        Self {
            physics,
            task: None,
            reward_fns: Vec::new(),
            observables: Vec::new(),
        }
    }

    /// 環境のタスクを設定する。
    ///
    /// 複数回呼び出された場合、以前のタスクは上書きされる。
    pub fn task(mut self, task: impl Task + 'static) -> Self {
        self.task = Some(Box::new(task));
        self
    }

    /// 報酬関数コンポーネントをリストに追加する。
    pub fn add_reward_fn(mut self, reward_fn: impl RewardFn + 'static) -> Self {
        self.reward_fns.push(Box::new(reward_fn));
        self
    }

    /// 観測要素コンポーネントをリストに追加する。
    pub fn add_observable(mut self, observable: impl Observable + 'static) -> Self {
        self.observables.push(Box::new(observable));
        self
    }

    /// これまでの設定を元に、最終的な環境オブジェクトを生成する。
    ///
    /// このメソッドは`Composer`の所有権を消費し、`Environment`トレイトを
    /// 実装した新しい構造体(`ComposedEnvironment`)を返す。
    pub fn build(self) -> ComposedEnvironment {
        ComposedEnvironment {
            physics: self.physics,
            task: self.task,
            reward_fns: self.reward_fns,
            observables: self.observables,
            //... その他の内部状態
        }
    }
}

/// Composerによって構築された、完全な環境を表す構造体。
/// (この構造体は通常、ライブラリのプライベートな実装詳細となる)
pub struct ComposedEnvironment {
    physics: Physics,
    task: Option<Box<dyn Task>>,
    reward_fns: Vec<Box<dyn RewardFn>>,
    observables: Vec<Box<dyn Observable>>,
}

// ComposedEnvironmentは、Environmentトレイトを実装することで、
// 標準的なRLエージェントと対話できるようになる。
impl Environment for ComposedEnvironment {
    //... step, reset などのメソッドを実装...
}
```

#### 設計の要点解説

  * **所有権ベースのAPI:** `Composer`のビルダーメソッドは`self`を値で受け取り、変更後の`self`を返します。これにより、構築プロセスが完了すると元のビルダーは利用できなくなり、状態の誤用を防ぎます。最終的に`.build()`は`self`を完全に消費し、所有権を完成した`ComposedEnvironment`に移します 。
  * **型消去 (`Box<dyn Trait>`)**: `reward_fns`や`observables`といったフィールドは、具体的な型（例：`VelocityReward`や`JointPositions`）が異なる複数のコンポーネントを保持する必要があります。`Box<dyn Trait>`（トレイトオブジェクト）を用いることで、これらの異なる型のオブジェクトを、共通の`trait`インターフェースを介して単一の`Vec`にまとめて格納できます [1]。
  * **柔軟性と不変条件のバランス:** `task`フィールドを`Option`とすることで、「タスクを持たない」という正当なユースケース（サンドボックス環境など）をサポートします。一方で、「タスクは通常一つ」というドメイン知識は、`.task()`メソッドが以前の値を上書きするという振る舞いによって表現され、APIの柔軟性を維持しています。
  * **関心の分離:** `Composer`の構造体定義そのものが、環境を構成する各要素（物理、タスク、報酬、観測）が明確に分離されていることを示しています。これにより、各コンポーネントは自身の責務に集中でき、高い再利用性と保守性を実現します。





### `oxide_control::composer::RewardFn` Trait：定義と設計

#### 1\. 概念：報酬関数の責務

`Composer`の設計思想において、`RewardFn`コンポーネントは、強化学習環境における\*\*「行動評価のロジック」\*\*という単一の責務を担います。

`RewardFn`は、ある瞬間の物理状態（`state`）を受け取り、その状態がタスクの目標に対してどれだけ「良い」または「悪い」かを評価し、単一の数値（スカラー値）である**報酬 (reward)** を返します。

このコンポーネントは、以下の要素から意図的に**分離**されています。

  * **`Task`から分離:** 「タスクの目標（例：前に進む）」と、「その達成度をどう評価するか（例：前進速度に比例した報酬）」は別の関心事です。これらを分離することで、同じタスクに対して様々な報酬設計を試すことが可能になります。
  * **`Observable`から分離:** エージェントが「観測できる情報」と、「報酬計算に使われる情報」は必ずしも一致しません。例えば、報酬計算にはシミュレータ内部の真の速度を使いたいが、エージェントにはノイズの乗ったセンサー値しか観測させない、といった設定が可能です。

#### 2\. `RewardFn` TraitのAPI定義

この責務をRustの`trait`として表現すると、以下のようになります。

```rust
use crate::physics::Physics;

/// 環境の物理状態を評価し、スカラーの報酬値を計算する機能を表すトレイト。
///
/// このトレイトを実装する各コンポーネントは、特定の報酬要素
/// （例：目標への近さ、エネルギー消費の少なさなど）を担当する。
pub trait RewardFn {
    /// 現在の物理状態から報酬値を計算する。
    ///
    /// # Arguments
    /// * `physics` - 現在のシミュレーション状態への読み取り専用参照。
    ///             このオブジェクトから、報酬計算に必要な物理量（位置、速度など）を取得する。
    ///
    /// # Returns
    /// 計算された報酬値 (`f32`)。
    fn calculate_reward(&self, physics: &Physics) -> f32;
}
```

#### 3\. API定義の解説

  * **`pub trait RewardFn`**
    この`trait`は`pub`（公開）であり、ライブラリの利用者が独自のカスタム報酬関数を自由に定義し、`Composer`に組み込むことができます。

  * **`fn calculate_reward(&self, physics: &Physics) -> f32`**

      * **`&self`:** `trait`メソッドの標準的なレシーバです。
      * **`physics: &Physics`:** 報酬計算には、現在の世界の物理状態を知る必要があります。`Physics`オブジェクトへの**読み取り専用参照**を受け取ることで、`RewardFn`は必要な情報（例：ボディの速度、関節の角度）に安全にアクセスできます。状態を読み取るだけで変更はしないため、不変参照（`&`）であることが重要です。
      * **`-> f32`:** 報酬は単一の評価値であるため、スカラーの浮動小数点数を返します。`f32`はパフォーマンスと精度のバランスが良く、機械学習の分野で広く使われる標準的な型です。

#### 4\. `Composer`における利用法と重み付け

`Composer`は、`.add_reward_fn()`メソッドを通じて、複数の`RewardFn`コンポーネントを受け取ります。

  * **報酬の合計:** `Environment::step`が呼ばれると、`Composer`は内部に保持している全ての`RewardFn`の`calculate_reward`メソッドを呼び出し、その結果を**合計**して、そのステップの最終的な報酬とします。

  * **重み付けの実装:**
    以前の議論でご指摘いただいた通り、各報酬の重要度を調整する「重み付け」は不可欠です。これは、`RewardFn`トレイトを実装した`Weighted`ラッパー構造体を用いることで、非常にエレガントに実現されます。

    ```rust
    // Weightedラッパーの定義（再掲）
    pub struct Weighted<R: RewardFn> {
        weight: f32,
        inner: R,
    }

    impl<R: RewardFn> RewardFn for Weighted<R> {
        fn calculate_reward(&self, physics: &Physics) -> f32 {
            self.inner.calculate_reward(physics) * self.weight
        }
    }

    // Composerでの利用例
    let env = Composer::new(physics)
      .task(...)
       //.add_reward_fnは、RewardFnトレイトを実装した任意の型を受け入れる
      .add_reward_fn(Weighted::new(1.0, ForwardVelocityReward))
      .add_reward_fn(Weighted::new(-0.1, ControlCostPenalty))
      .build();
    ```

この設計により、報酬計算のコアロジック（例：`ForwardVelocityReward`）と、その相対的な重要度（`weight`）が明確に分離されます。これにより、開発者は報酬のバランス調整を、環境定義のコード上で直感的に、かつ安全に行うことができるのです。




### `oxide_control::composer::Observable` Trait：定義と設計

#### 1\. 概念：Observableの責務

`Composer`の設計思想において、`Observable`コンポーネントは、強化学習エージェントが環境を\*\*「知覚」\*\*するための情報源を定義するという、単一の責務を担います。

これは、シミュレーションの物理的な「真の状態 (`state`)」から、エージェントの意思決定の入力となる「観測 (`observation`)」ベクトルを生成するプロセスをカプセル化したものです。`Observable`は、以下の問いに答えるロジックを実装します。

  * **エージェントは何を見ることができるか？**
    物理世界の膨大な情報の中から、どの部分をエージェントに公開するかを定義します。例えば、「全関節の角度」や「胴体の速度」、「特定のセンサーの値」などが個別の`Observable`コンポーネントとなります。

このコンポーネントは、他の要素から意図的に**分離**されています。

  * **`Task`や`RewardFn`から分離:** エージェントが観測できる情報と、タスクの終了条件や報酬計算に使われる情報は必ずしも一致しません。例えば、報酬計算にはシミュレータ内部の正確な目標位置を使いたいが、エージェントにはノイズの乗ったGPSセンサーの値しか観測させない、といった設定が可能です。この分離により、より現実的で挑戦的なPOMDP（部分観測マルコフ決定過程）環境を構築できます。

#### 2\. `Observable` TraitのAPI定義

この責務をRustの`trait`として表現すると、以下のようになります [1, 2, 3, 4]。

```rust
use nalgebra::DVector;
use crate::physics::Physics;

/// 環境から観測データの一部を抽出する機能を表すトレイト。
///
/// このトレイトを実装する各コンポーネントは、観測ベクトルを構成する
/// 特定の情報源（例：関節の角度、ボディの速度）を担当する。
pub trait Observable {
    /// このObservableが生成する観測データの次元数（ベクトルの要素数）。
    ///
    /// この値は不変でなければならない。
    fn dimension(&self) -> usize;

    /// 現在の物理状態から観測データを生成する。
    ///
    /// # Arguments
    /// * `physics` - 現在のシミュレーション状態への読み取り専用参照。
    ///
    /// # Returns
    /// 観測データを格納した動的ベクトル。ベクトルの長さは`dimension()`と
    /// 一致しなければならない。
    fn observe(&self, physics: &Physics) -> DVector<f32>;

    /// このObservableの名前（デバッグやロギング用）。
    fn name(&self) -> &'static str;
}
```

#### 3\. API定義の解説

  * **`pub trait Observable`**
    この`trait`は`pub`（公開）であり、ライブラリの利用者が独自のカスタム観測要素（例えば、特定のセンサーを模倣するもの）を自由に定義し、`Composer`に組み込むことができます [1]。

  * **`fn dimension(&self) -> usize`**

      * **目的:** この`Observable`が生成する観測ベクトルの長さを事前に知らせます。
      * **役割:** `Composer`は、`.build()`が呼ばれた際に、登録された全ての`Observable`の`dimension`を合計し、最終的な`Observation`ベクトルの全長を確定します。これにより、毎ステップで観測ベクトル用のメモリを再確保する必要がなくなり、パフォーマンスが向上します。

  * **`fn observe(&self, physics: &Physics) -> DVector<f32>`**

      * **目的:** これが`Observable`の核となる機能です。現在の物理状態から、自身の担当する情報を抽出します。
      * **引数:** `&Physics`（読み取り専用参照）を受け取ります。観測は現在の物理状態を**読み取る**だけでよく、変更する必要はないため、不変参照（`&`）であることが重要です。例えば、`JointPositions`という`Observable`は、`physics.data()`を介して全関節の角度（`qpos`）を読み出し、それをベクトルに詰めて返します。
      * **戻り値:** `nalgebra::DVector<f32>`を返します。これは、様々な長さの観測データを柔軟に扱うための動的なベクトルです。

  * **`fn name(&self) -> &'static str`**

      * **目的:** デバッグや観測空間の仕様を人間が可読な形で表示するために、各観測要素に名前を与えます。
      * **役割:** 例えば、環境の仕様を表示する際に、「観測空間（合計22次元）の内訳：`body_pose` (6), `joint_positions` (8), `joint_velocities` (8)」のように、分かりやすい情報を提供できます。

#### 4\. `Composer`における利用法

`Composer`は、`.add_observable()`メソッドを通じて、複数の`Observable`コンポーネントを受け取ります。

  * **観測ベクトルの構築:** `Environment::step`が呼ばれると、`Composer`は内部に保持している`Observable`のリストを、`.add_observable()`で追加された**順序通りに**イテレートします。そして、各`Observable`の`observe()`メソッドを呼び出し、返された部分ベクトルを**連結 (concatenate)** して、そのステップにおける最終的な単一の`Observation`ベクトルを生成します。

この設計により、複雑な観測空間を、意味のある小さな部品から宣言的に、かつ型安全に組み立てることが可能になります。研究者や開発者は、エージェントに与える情報を精密にコントロールし、様々な実験を容易に行うことができるのです。